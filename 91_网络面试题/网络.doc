第一部分：协议层次以及它们的服务类型
1.OSI 七层模型
应用层  作用是通过应用程序间的交互来完成特定的网络应用
表示层  作用是使通信的应用程序能够解释交换数据的含义
会话层  作用是负责建立、管理和终止表示层实体之间的通信会话
传输层  传输层的主要任务是为两台主机进程之间的通信提供服务
网络层  主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送
数据链路层  数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧
物理层  作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异

2.TCP/IP 参考模型
应用层  将OSI参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现
传输层  该层对应于 OSI 参考模型的传输层，为上层实体提供源端到对端主机的通信功能
网际互联层  网际互联层对应 OSI 参考模型的网络层，主要负责相同或不同网络中计算机之间的通信
网络访问层  网络接入层的功能对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换

3.TCP/IP 五层参考模型
应用层
传输层
网络层
数据链路层
物理层

4.OSI 模型和 TCP/IP 模型异同比较
相同点：都是采用了层次结构，都能够提供面向连接和无连接两种通信服务机制
不同点：OSI是七层模型，TCP/IP是四层
OSI是先有模型，后有协议规范，TCP/IP是先有协议集然后建立模型
TCP/IP 一开始就提出面向连接和无连接服务
OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。
OSI将网络划分七层，实现比较困难，TCP/IP分层简单，容易实现

5.OSI 和 TCP/IP 协议之间的对应关系
应用层（Application）
HTTP, TFTP, FTP, NFS, WAIS, SMTP, Telnet, DNS, SNMP
表示层（Presentation）
TIFF, GIF, JPEG, PICT
会话层（Session）
RPC, SQL, NFS, NetBIOS, names, AppleTalk
传输层（Transport）
TCP, UDP
网络层（Network）
IP, ICMP, ARP, RARP, RIP, IPX
数据链路层（Data Link）
FDDI, Frame Relay, HDLC, SLIP, PPP
物理层（Physical）
EIA/TIA-232, EIA/TIA-499, V.35, 802.3
tcp/ip将应用层表示层会话层合并为应用层
将数据链路层和物理层合并为数据链路层

6.为什么 TCP/IP 去除了表示层和会话层
因为会话层、表示层、应用层都是在应用程序内部实现的，最终产出的是一个应用数据包
所以TCP/IP协议便将表示层和会话层与应用层整合在一起，让整个过程更为清晰明了

7.数据如何在各层之间传输【数据的封装过程】
在发送主机端，一个应用层报文被传送到运输层，在最简单的情况下，
运输层收取到报文，并附上允许接收端运输层向上向适当的应用程序交付
报文的信息以及差错检测位信息。能让接收端能够判断报文中的比特是否被改变，
应用层报文和运输层首部信息一道构成了运输层报文段。
运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。
该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，
在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。


第二部分：应用层
1.HTTP 头部包含哪些信息
HTTP头部本质上是一个传递额外重要信息的键值对。
主要分为：通用头部，请求头部，响应头部和实体头部。
通用头部
Cache- Control   用来指定当前的请求/回复中是否使用缓存机制
Connection      客户端（浏览器）想要优先使用的连接类型
Date            报文创建时间
Trailer         会实现说明在报文主体后记录哪些首部字段，该首部字段可以使用在HTTP/1.1版本分块传输编码
Transfer-Encoding  用来改变报文格式
Upgrade      要求服务器升级到一个高版本协议
Via         告诉服务器，这个请求是由哪些代理发出的
Warning    一个一般性的警告，表示在实体内容中可能存在错误

2.Keep-Alive 和非 Keep-Alive 区别，对服务器性能有影响吗
keep-Alive 是长连接  浏览器发起HTTP请求后不会马上断开连接，
当长时间的保持 TCP 连接时容易导致系统资源被无效占用
可以设置keep-alive timeout参数，当TCP连接在传送完最后一个HTTP响应，该连接会保持
keepalive_timeout 秒，之后就开始关闭这个链接。
非keep-Alive是短连接 浏览器每次发起HTTP请求都要与服务器创建一个新的TCP连接，
服务器完成请求处理后立即断开TCP连接，创建和关闭连接的过程需要消耗资源和时间

3.HTTP 长连接短连接使用场景是什么
长连接多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况
短连接用户数目较多的Web网站的HTTP服务一般用短连接

4.怎么知道 HTTP 的报文长度
当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成
如果服务器预先不知道请求内容的大小，就需要使用 Transfer-Encoding: chunked 
的方式来代替Content-Length。当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要
预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束

5.HTTP 方法了解哪些
HTTP/1.0 定义了三种请求方法：GET POST HEAD 方法
HTTP/1.1 增加了六种请求方法：OPTIONS PUT PATCH DELETE TRACE  CONNECT 方法

6.GET 和 POST 的区别
get提交的的数据会放在URL后面,请求参数会被完整的保留在浏览器记录中，参数直接暴露不能传输重要数据
post参数放在请求主体中，参数不会被保留，相比get方法，post方法更安全
get只支持URL编码，post支持多种编码
get只支持ASCII字符格式的参数，而post方法没有限制
get提交的数据大小有限制，post方法提交的数据没限制.
get方式需要使用Request.QueryString来取得变量的值
post方式通过Request.Form来获取。

7.GET 的长度限制是多少
HTTP中的GET方法是通过URL传递数据的，而URL本身并没有对数据的长度进行限制，真正限制
GET长度的是浏览器
由于POST方法请求参数在请求主体中，理论上讲，post方法是没有大小限制的，
而真正起限制作用的是服务器处理程序的处理能力。

8.HTTP 与 HTTPs 的工作方式【建立连接的过程】
HTTP（Hyper Text Transfer Protocol: 超文本传输协议）是一种简单的请求-响应协议
HTTP使用的是TCP作为运输层协议，其默认工作在TCP协议80端口，连接建立浏览器和服务器
进程就可以通过套接字接口访问TCP，其通信内容以明文的方式发送，不通过任何方式的数据加密
HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer）是以安全为目标的HTTP协议
默认连接服务器443端口，在HTTP的基础上通过传输加密和身份认证的方式保证了传输过程的安全性
客服端发起连接请求，连接443端口，发送自身所支持的加密算法，
服务端把自己的信息以数字证书的形式返回给客户端（证书内容有密钥公钥，网站地址，证书颁发机构，失效日期等）。
证书中有一个公钥来加密信息，私钥由服务器持有。
客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）。
如果验证通过，或用户接受了不受信任的证书，浏览器就会生成一个随机的对称密钥（session key）并用公钥加密，
让服务端用私钥解密，解密后就用这个对称密钥进行传输了，并且能够说明服务端确实是私钥的持有者。

9.HTTPS 和 HTTP 的区别
HTTP 协议以明文方式发送内容，数据都是未加密的，安全性较差
HTTPS 数据传输过程是加密的，安全性较好
HTTP 页面响应比HTTPS快，因为HTTP使用3次握手建立连接，
而HTTPS除了TCP的3次握手，还需要经历一个SSL协商过程。
HTTP是80端口，HTTPS是443端口。

10.HTTPS 的加密方式
HTTPS 采用对称加密和非对称加密相结合的方式，首先使用 SSL/TLS 协议进行加密传输
通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息
都通过该对称秘钥进行加密解密，完成整个HTTPS的流程。

11.客户端为什么信任第三方证书
假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，
因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明
证书被中间人篡改，证书不可信，从而终止向服务器传输信息。

12.HTTP 是不保存状态的协议,如何保存用户状态
在客户端第一次向服务器发送HTTP请求后，服务器会创建一个Session对象并将客户端的
身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，
这个会话标识一般保存在客户端Cookie中，之后每次该浏览器发送HTTP请求都会带上
Cookie中的SessionId到服务器，服务器根据会话标识就可以将之前的状态信息与会话
联系起来，从而实现会话保持。

当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。
客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏
览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于
Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。


13.状态码
1XX	指示信息–表示请求正在处理
2XX	成功–表示请求已被成功处理完毕
3XX	重定向–要完成的请求需要进行附加操作
4XX	客户端错误–请求有语法错误或者请求无法实现，服务器无法处理请求
5XX	服务器端错误–服务器处理请求出现错误


14.HTTP/1.1 和 HTTP/1.0 的区别
1.0默认短连接，1.1默认长连接
HTTP/1.1 在 1.0 的基础上新增了24个错误状态响应码

15.HTTP/1.X 和 HTTP/2.0 的区别
HTTP/1.X使用文本（字符串）传送， HTTP/2.0 采用二进制传送
HTTP/2.0 支持多路复用
HTTP/2.0 头部压缩。HTTP/2.0通过gzip和compress压缩头部然后再发送，
HTTP/2.0 支持服务器推送


17.DNS 的作用和原理
DNS（Domain Name System）是域名系统的英文缩写，将域名和IP地址相互映射
的一个分布式数据库，能够使人更方便地访问互联网。
假设主机A（IP地址为abc.xyz.edu）想知道主机B的IP地址（def.mn.edu）
主机A首先向它的本地DNS服务器发送一个DNS查询报文，该查询报文含有被转换的主机名def.mn.edu
本地DNS服务器将该报文转发到根DNS服务器，根DNS服务器注意到查询的IP地址前缀为edu后向
本地DNS服务器返回负责edu的顶级域名服务器的IP地址列表
本地DNS服务器则再次向这些顶级域名服务器发送查询报文。该顶级域名服务器注意到mn.edu的前缀，
并用权威域名服务器的IP地址进行响应
本地DNS服务器直接向该服务器发送查询报文从而获得主机B的IP地址。

18.DNS 为什么用 UDP
当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为数据同
步传送的数据量比一个请求和应答的数据量要多，而 TCP 允许的报文长度更长，因此为了保证数据的正确性，
会使用基于可靠连接的 TCP。
当客户端向DNS服务器查询域名( 域名解析)的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节。
用UDP传输时，不需要经过TCP三次握手的过程，从而大大提高了响应速度，但这要求域名解析器和域名服务器
都必须自己处理超时和重传从而保证可靠性。

19.怎么实现 DNS 劫持
DNS 劫持即域名劫持，是通过将原域名对应的 IP 地址进行替换从而使得用户访问到错误的网站或者使得用户无法正常访问网站的一种攻击方式

20.socket() 套接字有哪些
流套接字（SOCK_STREAM）：流套接字基于 TCP 传输协议
数据报套接字（SOCK_DGRAM）：和流套接字不同，数据报套接字基于 UDP 传输协议
原始套接字（SOCK_RAW）当需要传送非传输层数据包（例如 Ping 命令时用的 ICMP 协议数据包）或者遇到操作系统无法处理的数据包时，此时就需要建立原始套接字来发送。

21.URI（统一资源标识符）和 URL（统一资源定位符）之间的区别
URL是URI的一个子集，两者都定义了资源是什么，而URL还定义了如何能访问到该资源
只要能唯一标识资源的就是URI，在URI的基础上给出其资源的访问方式的就是URL

22.为什么 fidder，charles 能抓到你的包【抓取数据包的过程】
我们需要抓取客户端的数据包，需要监控客户端与服务器交互之间的网络节点，
监控其中任意一个网络节点（网卡），获取所有经过网卡中的数据，
对这些数据按照网络协议进行解析，这就是抓包的基本原理

23.如果你访问一个网站很慢，怎么排查和解决
首先最直接的方法是查看本地网络是否正常
当网速测试正常时，我们对网站服务器速度进行排查，通过 ping 命令查看链接到服务器的时间和丢包等情况
如果网页打开的速度时快时慢，甚至有时候打不开，有可能是空间不稳定的原因
从网站本身找原因。网站的问题主要包括网站程序设计、网页设计结构和网页内容三个部分。

24.其他协议
FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议
TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议
SMTP（Simple Main Transfer Protocol，简单邮件传输协议）是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议
DHCP ( Dynamic Host Configuration Protocol，动态主机设置协议 ) 是一个局域网的网络协议
SNMP（Simple Network Management Protocol，简单网络管理协议）能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上关注的情况。

25.网页解析全过程【用户输入网址到显示对应页面的全过程】
1.DNS解析：当输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个IP地址，因此我们需要先把域名转换成相应IP地址
2.TCP 连接：浏览器通过DNS获取到Web服务器真正的IP地址后，便向Web服务器发起TCP连接请求，通过TCP三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了
3.发送HTTP请求：浏览器向Web服务器发起一个HTTP请求，在这一过程中，会涉及到负载均衡等操作。
4.处理请求并返回：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
5.浏览器渲染：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS
6.文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
7.断开连接：客户端和服务器通过四次挥手终止 TCP 连接

第三部分 传输层
3.1三次握手和四次挥手机制
1.首先客户端向服务器发送一个 SYN 包，并等待服务器确认
2.服务器接收到客户端发来的 SYN 包后，对该包进行确认后结束 LISTEN 阶段，并返回一段 TCP 报文
3.客户端接收到发送的 SYN + ACK 包后，明确了从客户端到服务器的数据传输是正常的，从而结束
 SYN-SENT 阶段。并返回最后一段报文
当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，
从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手

四次挥手
1.首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接
2.服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT
  阶段并返回一段 TCP 报文
3.服务器端在发出ACK确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经过
  CLOSE-WAIT阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段TCP报文 
4.客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束FIN-WAIT-2
  阶段，进入TIME-WAIT阶段，并向服务器发送一段报文
随后客户端开始在TIME-WAIT阶段等待2MSL  
服务器端收到从客户端发出的TCP报文之后结束LAST-ACK 阶段，进入CLOSED阶段
客户端等待完2 MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成「四次挥手」。

3.2如果三次握手的时候每次握手信息对方没有收到会怎么样
1.若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，
而客户端由于在一段时间内没有收到服务器发来的确认报文，因此会等待一段时间后重新发
送SYN同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，
建立连接的系统调用会返回-1。
2.若第二次握手客户端未接收到服务器回应的ACK报文时，客户端会采取第一次握手失败时的动作，
这里不再重复，而服务器端此时将阻塞在accept()系统调用处等待client再次发送 ACK 报文。
3.若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，
若重传次数超过限制后仍然没有回应，则accep()系统调用返回-1，服务器端连接建立失败。
但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的
accept()系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会发送 
RST报文给客户端，消除客户端单方面建立连接的状态。

3.3为什么要进行三次握手？两次握手可以吗？
三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。
若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，
而服务器并不知道客户端是否能够收到自己发送的数据。

3.4第 2 次握手传回了 ACK，为什么还要传回 SYN
ACK 是为了告诉客户端发来的数据已经接收无误，而传回 SYN 是为了告诉客户端，服务端收到的消息确实是客户端发送的消息。

3.5为什么要四次挥手？
因为FIN释放连接报文和ACK确认接收报文是分别在两次握手中传输的。当主动方在数据传送结束后发出连接释放的通知，
由于被动方可能还有必要的数据要处理，所以会先返回ACK确认收到报文。当被动方也没有数据再发送的时候，
则发出连接释放通知，对方确认后才完全关闭TCP连接。

3.6CLOSE-WAIT 和 TIME-WAIT 的状态和意义
在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了CLOSE-WAIT状态，
然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT 状态就是为了保证服务器
在关闭连接之前将待发送的数据发送完成。

TIME-WAIT 发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入该状态，若取消该状态，
即客户端在收到服务端的FIN报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在
相同的端口立即建立新的连接，则有可能接收到上一次连接中残留的数据包，可能会导致不可预料的异常出现

3.7TIME_WAIT 状态会导致什么问题，怎么解决
在高并发短连接的TCP服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 
TIME_WAIT状态，服务器维护每一个连接需要一个socket，也就是每个连接会占用一个文件描述符，
而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的连接失败。
解决方案：修改配置或设置SO_REUSEADDR套接字，使得服务器处于TIME-WAIT状态下的端口能够快速回收和重用。

3.8TIME-WAIT为什么是2MSL
当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完
ACK确认报文之后，会设置一个时长为2 MSL的计时器
MSL（Maximum Segment Lifetime），指一段TCP报文在传输过程中的最大生命周期。2 MSL
即是服务器端发出FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

若服务器在 1 MSL 内没有收到客户端发出的ACK确认报文，再次向客户端发出FIN报文。
如果客户端在2 MSL内收到了服务器再次发来的FIN报文，说明服务器由于一些原因并
没有收到客户端发出的ACK确认报文。客户端将再次向服务器发出ACK确认报文，并重新开始2 MSL的计时

若客户端在2MSL内没有再次收到服务器发送的FIN报文，则说明服务器正常接收到客户端 
ACK确认报文，客户端可以进入CLOSE阶段，即完成四次挥手。
所以客户端要经历2MSL时长的TIME-WAIT阶段，为的是确认服务器能否接收到客户端发出的ACK
确认报文。

3.9有很多 TIME-WAIT 状态如何解决
服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口被占用，
但TCP连接位于TIME_WAIT状态时可以重用端口。如果你的服务器程序停止
后想立即重启，而新的套接字依旧希望使用同一端口，此时 O_REUSEADDR 
选项就可以避免TIME-WAIT状态。
也可以采用长连接的方式减少TCP的连接与断开，在长连接的业务中往往
不需要考虑TIME-WAIT状态，但其实在长连接的业务中并发量一般不会太高。

3.10有很多 CLOSE-WAIT 怎么解决
首先检查是不是自己的代码问题（看是否服务端程序忘记关闭连接），如果是，则修改代码
调整系统参数，包括句柄相关参数和TCP/IP的参数，一般一个CLOSE_WAIT会维持至少
2个小时的时间，我们可以通过调整参数来缩短这个时间

3.11TCP 和 UDP 的区别
TCP是面向连接传输可靠字节流传输效率慢所需资源多首部字节20~60字节
UDP不是面向连接传输不可靠数据报传输效率快所需资源少首部字节8个字节

3.12TCP 协议中的定时器
TCP中有七种计时器
建立连接定时器
重传定时器
坚持计时器
延迟应答计时器
保活定时器
FIN_WAIT_2 定时器
TIME_WAIT 定时器

3.13TCP 是如何保证可靠性的
数据分块
序列号和确认应答
校验和
流量控制
拥塞控制
ARQ协议
超时重传

3.14UDP为什么是不可靠的？bind和connect对于UDP的作用是什么
UDP只有一个socket接收缓冲区，没有socket发送缓冲区，即只要有数据就发，不管对方是否可以正确接收
而在对方的socket接收缓冲区满了之后，新来的数据报无法进入到socket接受缓冲区， 
此数据报就会被丢弃，因此UDP不能保证数据能够到达目的地

和TCP建立连接时采用三次握手不同，UDP中调用connect只是把对端的IP和端口号记录下来，并且UDP 
可多多次调用connect来指定一个新的IP和端口号，或者断开旧的IP和端口号（通过设置connect函数的第二个参数）。
和普通的UDP相比，调用connect的UDP会提升效率，并且在高并发服务中会增加系统稳定性

当UDP的发送端调用bind函数时，就会将这个套接字指定一个端口，若不调用bind函数，
系统内核会随机分配一个端口给该套接字

3.15TCP 超时重传的原理
发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的
ACK报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。


3.16TCP 的停止等待协议是什么
停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，
直到收到接收方的确认信号才继续发送下一组数据
1.无差错传输
A发送分组Msg1，发完就暂停发送，直到收到接收方确认收到Msg1的报文后，继续发送Msg2
2.出现差错
发送方发送的Msg1在中途丢失了，接收方完全没收到数据
接收方收到Msg1后检测出现了差错，直接丢弃Msg1
上面两种情形，接收方都不会回任何消息给发送方，此时就会触发超时传输机制，
即发送方在等待一段时间后仍然没有收到接收方的确认，就认为刚才发送的数据丢失了，
因此重传前面发送过的数据。
3.确认丢失
当接收方回应的Msg1确认报文在传输过程中丢失，发送方无法接收到确认报文。
于是发送方等待一段时间后重传Msg1，接收方将收到重复的Msg1数据包，
此时接收方会丢弃掉这个重复报文并向发送方再次发送Msg1的确认报文。
4.确认迟到
当接收方回应的Msg1确认报文由于网络各种原因导致发送方没有及时收到，
此时发送方在超时重传机制的作用下再次发送了Msg数据包，接收方此时进行
和确认丢失情形下相同的动作（丢弃重复的数据包并再次发送Msg 1确认报文）。
发送方此时收到了接收方的确认数据包，于是继续进行数据发送。过了一段时间后
发送方收到了迟到的Msg1确认包会直接丢弃。

3.17TCP 最大连接数限制
client在每次发起TCP连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口
该端口是独占的，不能和其他TCP连接共享。TCP端口的数据类型是unsigned short，
因此本地端口个数最大只有65536，除了端口0不能使用外，其他端口在空闲时都可以正常使用，
这样可用端口最多有65535个。

server通常固定在某个本地端口上监听，等待client的连接请求。不考虑地址重用（Unix的
SO_REUSEADDR 选项）的情况下，即使server端有多个IP，本地监听端口也是独占的，因此
server端TCP连接4元组中只有客户端的IP地址和端口号是可变的，因此最大TCP连接为客户端
IP数×客户端port数，对IPV4，在不考虑 IP 地址分类的情况下，最大TCP连接数约为 
2的32次方（IP数）× 2的16次方（port数），也就是server端单机最大TCP连接数约为2的48次方。

在实际环境中，受到明文规定（一些IP地址和端口具有特殊含义，没有对外开放）、机器资源、
操作系统等的限制，特别是sever端，其最大并发TCP连接数远不能达到理论上限。
对server端，通过增加内存、修改最大文件描述符个数等参数，单机最大并发TCP
连接数超过10万是没问题的。

3.18TCP 流量控制与拥塞控制
流量控制就是让发送方的发送速率不要太快，让接收方来得及接收
如果接收方来不及接收发送方发送的数据，那么就会有分组丢失.在TCP中利用
可边长的滑动窗口机制可以很方便的在TCP连接上实现对发送方的流量控制。
主要的方式是接收方返回的ACK中会包含自己的接收窗口大小，
以控制发送方此次发送的数据量大小（发送窗口大小）。

拥塞控制
在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等
复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，
它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。
常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。

拥塞控制和流量控制的区别
拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点
只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处，
因此，流量控制往往指点对点通信量的控制，是端到端的问题。

3.19如果接收方滑动窗口满了，发送方会怎么做
基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的ACK包中
会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收
窗口大小为0，此时发送方会等待接收方发送的窗口大小直到变为非0为止，
然而，接收方回应的ACK包是存在丢失的可能的，为了防止双方一直等待而
出现死锁情况，此时就需要坚持计时器来辅助发送方周期性地向接收方查询，
以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，
发送方便继续发送数据。

3.20TCP 拥塞控制采用的四种算法
慢开始
当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的
数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在
一开始发送少量的数据先探测一下网络状况， 即由小到大的增大发送窗口
（拥塞窗口cwnd）。慢开始的慢指的是初始时令cwnd为1，即一开始发送一个报文段。
如果收到确认，则cwnd=2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。

拥塞避免
拥塞控制是为了让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT
（往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的
cwnd值加1，通过让cwnd线性增长，防止很快就遇到网络拥塞状态。
当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,
并将拥塞窗口置为1 ,然后再次重复两种算法（慢开始和拥塞避免）,
这时一瞬间会将网络中的数据量大量降低。

快重传
快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，
而不要等到自己发送数据时才捎带进行确认由于发送方尽早重传未被确认的报文段，
因此，快重传算法可以提高网络的吞吐量。

快恢复
快恢复算法是和快重传算法配合使用的
1.当发送方连续收到三个重复确认，执行乘法减小，慢开始门限ssthresh值减半
2.由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把cwnd值设置为
 ssthresh减半之后的值，然后执行拥塞避免算法，线性增大cwnd。

3.21TCP 粘包问题
为什么会发生TCP粘包和拆包?
1.发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包
2.发送方写入的数据小于套接字缓冲区大小，由于TCP默认使用Nagle算法，
只有当收到一个确认后，才将分组发送给对端，当发送方收集了多个较小的分组，
就会一起发送给对端，这将会发生粘包。
3.进行MSS（最大报文长度）大小的TCP分段，当TCP报文的数据部分大于MSS 
的时候将发生拆包。
4.发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包

解决方法
1.在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，
然后向后读取相应长度的内容。
2.固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，
当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。
3.设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界
分离出消息内容，一般使用换行符。

什么时候需要处理粘包问题？
当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；
而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题。

3.22TCP 报文包含哪些信息
源端口和目的端口号
序号和确认号字段
首部长度 保留 控制位 接收窗口
校验和  紧急数据指针
选项 
数据

3.23SYN FLOOD 是什么
SYN Flood 是种典型的 DoS（拒绝服务）攻击，其目的是通过消耗服务器
所有可用资源使服务器无法用于处理合法请求。通过重复发送初始连接请求
（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，
导致目标设备根本不响应合法请求

3.24为什么服务端易受到 SYN 攻击
在 TCP 建立连接的过程中，因为服务端不确定自己发给客户端的SYN-ACK消息或
客户端反馈的ACK消息是否会丢在半路，所以会给每个待完成的半开连接状态设一
个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 
SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。

服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造
海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。
攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，
直到资源耗尽，停止响应正常的连接请求。


3.25高并发服务器客户端主动关闭连接和服务端主动关闭连接的区别第四部分、网络层
在高并发场景下，当服务端主动关闭连接时，此时服务器上就会有大量的连接处于TIME-WAIT状态
当客户端主动关闭连接时，我们并不需要关心 TIME-WAIT 状态过多造成的问题，
但是需要关注服务端保持大量的 CLOSE-WAIT 状态时会产生的问题

4.1IP 协议的定义和作用
IP 协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。
该协议工作在网络层，主要目的就是为了提高网络的可扩展性，和传输层TCP相比，
IP协议提供一种无连接/不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）
一起构成了TCP/IP 协议族的核心
IP 协议主要有以下几个作用：
1.寻址和路由：在IP数据包中会携带源IP地址和目的IP地址来标识该数据包的源主机和目的主机。
2.分段与重组：IP 数据包在传输过程中可能会经过不同的网络，在不同的网络中数据包的最大
长度限制是不同的，IP 协议通过给每个 IP 数据包分配一个标识符以及分段与组装的相关信息，
使得数据包在不同的网络中能够传输，被分段后的 IP 数据报可以独立地在网络中进行转发，
在到达目的主机后由目的主机完成重组工作，恢复出原来的 IP 数据包。


4.2域名和 IP 的关系，一个 IP 可以对应多个域名吗
IP在同一个网络中是唯一的，用来标识每一个网络上的设备，其相当于一个人的身份证号；
域名在同一个网络中也是唯一的，就像一个人的名字，绰号。假如你有多个不同的绰号，
你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是唯一的。
由此我们可以看出一个域名只能对应一个IP地址，是一对一的关系；
而一个IP却可以对应多个域名，是一对多的关系。

4.3IPV4 地址不够如何解决
DHCP：动态主机配置协议。动态分配IP地址，只给接入网络的设备分配IP地址，因此同一个
MAC地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的IP
地址可以得到充分利用。

CIDR：无类别域间路由。CIDR消除了传统的A类、B类、C类地址以及划分子网的概念，
因而更加有效的分配IPv4的地址空间，但无法从根本上解决地址耗尽问题。

NAT：网络地址转换协议。我们知道属于不同局域网的主机可以使用相同的IP地址，
从而一定程度上缓解了IP资源枯竭的问题。然而主机在局域网中使用的IP地址
是不能在公网中使用的，当局域网主机想要与公网进行通信时，NAT方法可以将该主机 
IP地址转换成全球IP地址。该协议能够有效解决IP地址不足的问题。

IPv6：作为接替IPv4的下一代互联网协议，其可以实现2的128次方个地址，而这个数量级， 
即使是给地球上每一颗沙子都分配一个IP地址，该协议能够从根本上解决IPv4地址不够用的问题。

4.4路由器的分组转发流程
1.从IP数据包中提取出目的主机的IP地址，找到其所在的网络；
2.判断目的IP地址所在的网络是否与本路由器直接相连，如果是，则不需要经过其它路由器直接交付，否则执行3
3.检查路由表中是否有目的IP地址的特定主机路由。如果有，则按照路由表传送到下一跳路由器中，否则执行4
4.逐条检查路由表，若找到匹配路由，则按照路由表转发到下一跳路由器中，否则执行步骤5
5.若路由表中设置有默认路由，则按照默认路由转发到默认路由器中，否则执行步骤6
6.无法找到合适路由，向源主机报错

4.5路由器和交换机的区别
交换机：交换机用于局域网，利用主机的物理地址（MAC地址）确定数据转发的目的地址，它工作与数据链路层。
路由器：路由器通过数据包中的目的IP地址识别不同的网络从而确定数据转发的目的地址，
网络号是唯一的。路由器根据路由选择协议和路由表信息从而确定数据的转发路径，
直到到达目的网络，它工作于网络层。

4.6ICMP 协议概念/作用
ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要是实现IP协议中未实现
的部分功能，是一种网络层协议。该协议并不传输数据，只传输控制信息来辅助网络层通信。其主要的
功能是验证网络是否畅通（确认接收方是否成功接收到IP数据包）以及辅助IP协议实现可靠传输
（若发生IP包，ICMP会通知发送方IP数据包被丢弃的原因，之后发送方会进行相应的处理）。

4.7ICMP 的应用
1.Ping
Ping（Packet Internet Groper），即因特网包探测器，是一种工作在网络层的服务命令，
主要用于测试网络连接量。本地主机通过向目的主机发送ICMP Echo请求报文，目的主机收到
之后会发送 Echo 响应报文，Ping 会根据时间和成功响应的次数估算出数据包往返时间以及
丢包率从而推断网络是否通常、运行是否正常等。

2.TraceRoute
TraceRoute是ICMP的另一个应用，其主要用来跟踪一个分组从源点耗费最少TTL到达目的地的路径。
TraceRoute通过逐渐增大TTL值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 
TTL为1的IP数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将TTL的值减1，
此时TTL = 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着
发送一个TTL为2的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时TTL=0，
因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的
主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

4.8两台电脑连起来后ping不通，你觉得可能存在哪些问题？
1.首先看网络是否连接正常，检查网卡驱动是否正确安装。
2.局域网设置问题，检查IP地址是否设置正确。
3.看是否被防火墙阻拦（有些设置中防火墙会对ICMP报文进行过滤），如果是的话，尝试关闭防火墙 
4.看是否被第三方软件拦截。
5.两台设备间的网络延迟是否过大（例如路由设置不合理），导致ICMP报文无法在规定的时间内收到。

4.9 ARP地址解析协议的原理和地址解析过程
ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据IP地址获取物理
地址的功能，它工作在第二层，是一个数据链路层协议，其在本层和物理层进行联系，同时向上层
提供服务，当通过以太网发送IP数据包时，需要先封装32位的IP地址和48位MAC地址。
在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道目标IP地址，
不知道其MAC地址，因此需要使用地址解析协议
1.首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系；
2.当源主机要发送数据时，首先检查ARP列表中是否有IP地址对应的目的主机MAC地址，如果存在，
则可以直接发送数据，否则就向同一子网的所有主机发送ARP数据包。该数据包包括的内容有源主机的 
IP地址和MAC地址，以及目的主机的IP地址。
3.当本网络中的所有主机收到该ARP数据包时，首先检查数据包中的目的主机IP地址是否是自己的
IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到
ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己
是它想要找的MAC地址。
4.源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。
如果源主机一直没有收到ARP响应数据包，表示ARP查询失败

4.10网络地址转换 NAT
NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成
公有网络IP地址的技术。该技术不仅能解决IP地址不足的问题，而且还能隐藏和保护网络内部主机，
从而避免来自外部网络的攻击。
NAT的实现方式主要有三种：
1.静态转换：内部私有IP地址和公有IP地址是一对一的关系，并且不会发生改变。通过静态转换，
可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有IP地址被占用时，
跟这个IP绑定的内部主机将无法访问Internet。
2.动态转换：采用动态转换的方式时，私有IP地址每次转化成的公有IP地址是不唯一的。当私有
IP地址被授权访问Internet时会被随机转换成一个合法的公有IP地址。当ISP通过的合法IP 
地址数量略少于网络内部计算机数量时，可以采用这种方式。
3.端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，
实现内部网络所有主机共享一个合法的外部IP地址进行Internet访问，从而最大限度地节约 
IP地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自Internet的攻击

4.11TTL 是什么？有什么作用
TTL是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后TTL就减一， 
这样TTL最终会减为0 ，当TTL为0时，则将数据包丢弃。通过设置TTL可以避免这两个路由器之间
形成环导致数据包在环路上死转的情况，由于有了TTL，当TTL为0时，数据包就会被抛弃。

4.12运输层协议和网络层协议的区别第五部分：数据链路层
网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。

5.1MAC 地址和 IP 地址分别有什么作用
5.2为什么有了 MAC 地址还需要 IP 地址
5.3为什么有了 IP 地址还需要 MAC 地址
5.4私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗
5.5以太网中的 CSMA/CD 协议
5.6数据链路层上的三个基本问题
5.7PPP 协议
5.8为什么 PPP 协议不使用序号和确认机制第六部分：物理层
6.1物理层主要做什么事情
6.2主机之间的通信方式
6.3通道复用技术
6.3 几种常用的宽带接入技术第七部分：计算机网络中的安全
7.1安全攻击有哪些
7.2ARP 攻击
7.3对称加密和非对称的区别，非对称加密有哪些
7.4AES 的过程
7.4RSA 和 AES 算法有什么区别
7.5DDoS 有哪些，如何防范